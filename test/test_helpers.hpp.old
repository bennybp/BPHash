#pragma once

#include "bphash/Hasher.hpp"
#include "bphash/types/All.hpp"

#include <iostream>


inline std::string MakeTypeStr(const char * container, const char * type)
{
    std::string s(container);
    s += "<";
    s += type;
    s += ">";
    return s;
}

inline std::string MakeArrayTypeStr(size_t N, const char * type)
{
    std::string s("std::array<");
    s += type;
    s += ",";
    s += std::to_string(N);
    s += ">";
    return s;
}

template<typename T>
void TestSingle(const char * type, const T & val,
                bphash::HashType htype,
                std::vector<bphash::HashValue> & found_hashes)
{
    using namespace bphash;
    using namespace std;

    // raw value
    Hasher h(htype);
    h(val);

    // Raw pointer
    const T * valptr = new T(val);
    Hasher hptr(htype);
    hptr(valptr);
    delete valptr;

    // unique_ptr
    Hasher huptr(htype);
    unique_ptr<T> uptr(new T(val));
    huptr(uptr);

    // shared_ptr
    Hasher hsptr(htype);
    shared_ptr<T> sptr(new T(val));
    hsptr(sptr);

    HashValue val_hash = h.finalize();
    HashValue ptr_hash = hptr.finalize();
    HashValue uptr_hash = huptr.finalize();
    HashValue sptr_hash = hsptr.finalize();

    // output the results
    cout << type << "\n";
    cout << "      normal: " << hash_to_string(val_hash) << "\n"
         << "       trunc: " << hash_to_string(truncate_hash(val_hash, 8)) << "\n"
         << "        conv: " << convert_hash<size_t>(val_hash) << "\n";

    cout << "     raw ptr: " << hash_to_string(ptr_hash) << "\n"
         << "       trunc: " << hash_to_string(truncate_hash(ptr_hash, 8)) << "\n"
         << "        conv: " << convert_hash<size_t>(ptr_hash) << "\n";

    cout << "  unique_ptr: " << hash_to_string(uptr_hash) << "\n"
         << "       trunc: " << hash_to_string(truncate_hash(uptr_hash, 8)) << "\n"
         << "        conv: " << convert_hash<size_t>(uptr_hash) << "\n";

    cout << "  shared_ptr: " << hash_to_string(sptr_hash) << "\n"
         << "       trunc: " << hash_to_string(truncate_hash(sptr_hash, 8)) << "\n"
         << "        conv: " << convert_hash<size_t>(sptr_hash) << "\n";

    found_hashes.push_back(move(val_hash));
    found_hashes.push_back(move(ptr_hash));
    found_hashes.push_back(move(uptr_hash));
    found_hashes.push_back(move(sptr_hash));
}


template<typename T, typename InputIt>
void TestContainer(const char * type, const InputIt first, const InputIt last,
                   bphash::HashType htype,
                   std::vector<bphash::HashValue> & found_hashes)
{
    T cont(first, last);
    TestSingle<T>(type, cont, htype, found_hashes);
}

template<typename T, size_t N, typename InputIt>
void TestArray(const char * type, const InputIt first,
               bphash::HashType htype,
               std::vector<bphash::HashValue> & found_hashes)
{
    std::array<T, N> arr;
    for(size_t i = 0; i < N; i++)
        arr[i] = *(first + i);

    TestSingle<std::array<T, N>>(MakeArrayTypeStr(N, type).c_str(),
                                 arr, htype, found_hashes);    
}


template<typename T, typename InputIt>
void TestContainers(const char * type, const InputIt first, const InputIt last,
                    bphash::HashType htype,
                    std::vector<bphash::HashValue> & found_hashes)
{
    std::string vector_str = MakeTypeStr("std::vector", type);
    std::string list_str = MakeTypeStr("std::list", type);
    std::string forward_list_str = MakeTypeStr("std::forward_list", type);
    std::string set_str = MakeTypeStr("std::set", type);
    std::string unordered_set_str = MakeTypeStr("std::unordered_set", type);

    TestContainer< std::vector<T>        >(vector_str.c_str(),        first, last, htype, found_hashes);
    TestContainer< std::list<T>          >(list_str.c_str(),          first, last, htype, found_hashes);
    TestContainer< std::forward_list<T>  >(forward_list_str.c_str(),  first, last, htype, found_hashes);
    TestContainer< std::set<T>           >(set_str.c_str(),           first, last, htype, found_hashes);
    TestContainer< std::unordered_set<T> >(unordered_set_str.c_str(), first, last, htype, found_hashes);

    // arrays have to be handled slightly differently
    auto d = std::distance(first, last);

    switch(d)
    {
        case 1:
            TestArray<T, 1>(type, first, htype, found_hashes);
            break;
        case 2:
            TestArray<T, 2>(type, first, htype, found_hashes);
            break;
        case 3:
            TestArray<T, 3>(type, first, htype, found_hashes);
            break;
        case 4:
            TestArray<T, 4>(type, first, htype, found_hashes);
            break;
        case 5:
            TestArray<T, 5>(type, first, htype, found_hashes);
            break;
        case 6:
            TestArray<T, 6>(type, first, htype, found_hashes);
            break;
        case 7:
            TestArray<T, 7>(type, first, htype, found_hashes);
            break;
        case 8:
            TestArray<T, 8>(type, first, htype, found_hashes);
            break;
    }
}


template<typename T
void TestAll(const char * type,
             const std::vector<T> & values,
             bphash::HashType htype,
             std::vector<bphash::HashValue> & found_hashes)
{
    // test each value
    for(const auto & it :  

}
